03/08/2025
import os
import json
import logging
from fastapi import FastAPI, Request
from pymongo import MongoClient
from datetime import datetime
from fastapi.responses import JSONResponse
from dotenv import load_dotenv
import certifi
import httpx

load_dotenv()

app = FastAPI()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("bot")

# === Variables de entorno ===
TOKEN = os.getenv("BOT_TOKEN")
MONGO_URI = os.getenv("MONGO_URI")
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
OPENROUTER_MODEL = os.getenv("OPENROUTER_MODEL", "mistralai/mistral-7b-instruct")
BASE_URL = f"https://api.telegram.org/bot{TOKEN}"

# === Categor√≠as v√°lidas ===
CATEGORIAS_VALIDAS = [
    "salud", "limpieza", "alimentacion", "transporte",
    "salidas", "ropa", "plantas", "arreglos casa", "vacaciones"
]

# === MongoDB ===
mongo_client = MongoClient(MONGO_URI, tlsCAFile=certifi.where())
db = mongo_client["telegram_gastos"]
movimientos = db["movimientos"]

# === Procesamiento con modelo ===
def procesar_con_openrouter(texto_usuario: str):
    prompt = f"""
Extrae el monto y la categor√≠a de gasto desde el siguiente texto. La categor√≠a debe estar dentro del siguiente listado: salud, limpieza, alimentacion, transporte, salidas, ropa, plantas, arreglos casa, vacaciones.

Si el texto indica que se debe agregar dinero, el monto debe ser positivo.
Si el texto indica que se debe resetear, el monto debe ser 0.
Si el texto indica que es un gasto, el monto debe ser negativo.

Devuelve solo un JSON con las claves: "monto" (n√∫mero) y "categoria" (texto exacto del listado). Nada m√°s.

Texto: "{texto_usuario}"
"""

    headers = {
        "Authorization": f"Bearer {OPENROUTER_API_KEY}",
        "Content-Type": "application/json",
        "HTTP-Referer": "https://tubot.com"
    }

    body = {
        "model": OPENROUTER_MODEL,
        "messages": [{"role": "user", "content": prompt}]
    }

    try:
        response = httpx.post(
            "https://openrouter.ai/api/v1/chat/completions",
            headers=headers,
            json=body,
            timeout=30
        )
        response.raise_for_status()
        content = response.json()["choices"][0]["message"]["content"]
        return json.loads(content)
    except Exception as e:
        logger.exception("‚ùå Error en OpenRouter:")
        return {"error": str(e), "raw": content if 'content' in locals() else ""}

# === Guardar en Mongo ===
def guardar_movimiento(chat_id, tipo, monto, categoria, mensaje_original):
    movimientos.insert_one({
        "chat_id": chat_id,
        "tipo": tipo,
        "monto": monto,
        "categoria": categoria,
        "mensaje_original": mensaje_original,
        "fecha": datetime.utcnow()
    })
    logger.info(f"üíæ Guardado: {tipo} S/ {monto} en {categoria} ({chat_id})")

def obtener_saldo(categoria, chat_id):
    pipeline = [
        {"$match": {"chat_id": chat_id, "categoria": categoria}},
        {"$group": {"_id": "$tipo", "total": {"$sum": "$monto"}}}
    ]
    result = list(movimientos.aggregate(pipeline))
    ingresos = sum(r["total"] for r in result if r["_id"] == "ingreso")
    gastos = sum(r["total"] for r in result if r["_id"] == "gasto")
    return ingresos - gastos

def obtener_reporte_general(chat_id):
    pipeline = [
        {"$match": {"chat_id": chat_id}},
        {"$group": {"_id": {"categoria": "$categoria", "tipo": "$tipo"}, "total": {"$sum": "$monto"}}}
    ]
    result = list(movimientos.aggregate(pipeline))
    saldos = {}
    for r in result:
        cat = r["_id"]["categoria"]
        tipo = r["_id"]["tipo"]
        saldos.setdefault(cat, {"ingreso": 0, "gasto": 0})
        saldos[cat][tipo] += r["total"]

    mensaje = "üìä Reporte general:\n"
    for cat, vals in saldos.items():
        saldo = vals["ingreso"] - vals["gasto"]
        mensaje += f"‚Ä¢ {cat}: S/ {saldo:.2f}\n"
    return mensaje

# === Rutas ===
@app.get("/")
async def root():
    return {"message": "Bot activo con MongoDB y OpenRouter ‚úÖ"}

@app.post(f"/{TOKEN}")
async def telegram_webhook(req: Request):
    try:
        body = await req.json()
        logger.info(f"üì© Mensaje recibido: {body}")

        chat_id = body["message"]["chat"]["id"]
        text = body["message"].get("text", "").strip()

        if not text:
            return {"ok": True}

        if text.lower() in ["reporte", "reporte general", "todo"]:
            msg = obtener_reporte_general(chat_id)
        elif text.lower().startswith("reporte de "):
            categoria = text.lower().replace("reporte de ", "").strip()
            if categoria not in CATEGORIAS_VALIDAS:
                msg = f"‚ùå Categor√≠a inv√°lida. Usa: {', '.join(CATEGORIAS_VALIDAS)}"
            else:
                saldo = obtener_saldo(categoria, chat_id)
                msg = f"üíº Saldo en '{categoria}': S/ {saldo:.2f}"
        else:
            resultado = procesar_con_openrouter(text)
            if "error" in resultado or resultado.get("categoria") not in CATEGORIAS_VALIDAS:
                msg = (
                    "‚ö†Ô∏è No pude interpretar tu mensaje correctamente.\n"
                    "Ejemplo: 'gast√© 30 en transporte' o 'ahorr√© 50 para salud'\n"
                    "Categor√≠as v√°lidas:\n" + "\n".join(f"- {c}" for c in CATEGORIAS_VALIDAS)
                )
            else:
                monto = resultado["monto"]
                categoria = resultado["categoria"]
                tipo = "ingreso" if monto >= 0 else "gasto"
                guardar_movimiento(chat_id, tipo, abs(monto), categoria, text)
                saldo = obtener_saldo(categoria, chat_id)
                msg = (
                    f"‚úÖ {tipo.title()} de S/ {abs(monto):.2f} registrado en '{categoria}'.\n"
                    f"üí∞ Saldo actual en '{categoria}': S/ {saldo:.2f}"
                )

        # Enviar respuesta
        httpx.post(f"{BASE_URL}/sendMessage", json={
            "chat_id": chat_id,
            "text": msg
        })
        return {"ok": True}

    except Exception as e:
        logger.exception("‚ùå Error inesperado:")
        return JSONResponse(status_code=500, content={"error": str(e)})

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


from fastapi import FastAPI, Request
import httpx
import os
import json

app = FastAPI()

# Claves de entorno
TOKEN = os.getenv("BOT_TOKEN")
BASE_URL = f"https://api.telegram.org/bot{TOKEN}"
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
OPENROUTER_MODEL = "mistralai/mistral-7b-instruct"  # puedes cambiarlo si quieres

# Categor√≠as v√°lidas
CATEGORIAS_VALIDAS = [
    "salud", "limpieza", "alimentacion", "transporte",
    "salidas", "ropa", "plantas", "arreglos casa", "vacaciones"
]

# Funci√≥n para llamar al modelo
def procesar_con_openrouter(texto_usuario: str):
    prompt = f"""
Extrae el monto y la categor√≠a de gasto desde el siguiente texto. La categor√≠a debe estar dentro del siguiente listado: salud, limpieza, alimentacion, transporte, salidas, ropa, plantas, arreglos casa, vacaciones.

Si el texto indica que se debe agregar dinero, el monto debe ser positivo.
Si el texto indica que se debe resetear, el monto debe ser 0.
Si el texto indica que es un gasto, el monto debe ser negativo.

Devuelve solo un JSON con las claves: "monto" (n√∫mero) y "categoria" (texto exacto del listado). Nada m√°s.

Texto: "{texto_usuario}"
"""

    headers = {
        "Authorization": f"Bearer {OPENROUTER_API_KEY}",
        "Content-Type": "application/json",
        "HTTP-Referer": "https://tubot.com"  # opcional
    }

    body = {
        "model": OPENROUTER_MODEL,
        "messages": [
            {"role": "user", "content": prompt}
        ]
    }

    try:
        response = httpx.post("https://openrouter.ai/api/v1/chat/completions", json=body, headers=headers, timeout=20)
        response.raise_for_status()
        content = response.json()["choices"][0]["message"]["content"]
        resultado = json.loads(content)
        return resultado
    except Exception as e:
        return {"error": str(e), "raw": content if 'content' in locals() else ""}

# Endpoint base
@app.get("/")
async def root():
    return {"message": "Bot activo con OpenRouter y variables seguras ‚úÖ"}

# Webhook de Telegram
@app.post(f"/{TOKEN}")
async def telegram_webhook(req: Request):
    data = await req.json()
    chat_id = data["message"]["chat"]["id"]
    text = data["message"].get("text", "")

    resultado = procesar_con_openrouter(text)

    if "error" in resultado or resultado.get("categoria") not in CATEGORIAS_VALIDAS:
        respuesta = (
            "‚ö†Ô∏è No pude interpretar tu mensaje correctamente.\n"
            "Aseg√∫rate de incluir una categor√≠a v√°lida y un monto.\n"
            "Categor√≠as disponibles:\n" + "\n".join(f"- {c}" for c in CATEGORIAS_VALIDAS)
        )
    else:
        respuesta = (
            f"üßæ *Movimiento detectado por IA:*\n"
            f"- üí∏ Monto: {resultado['monto']} soles\n"
            f"- üóÇÔ∏è Categor√≠a: {resultado['categoria']}"
        )

    # Enviar respuesta
    httpx.post(f"{BASE_URL}/sendMessage", json={
        "chat_id": chat_id,
        "text": respuesta,
        "parse_mode": "Markdown"
    })

    return {"ok": True}



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
from fastapi import FastAPI, Request
import httpx
import os

app = FastAPI()

TOKEN = os.getenv("BOT_TOKEN")
BASE_URL = f"https://api.telegram.org/bot{TOKEN}"

@app.get("/")
async def root():
    return {"message": "Bot activo!"}

@app.post(f"/{TOKEN}")
async def telegram_webhook(req: Request):
    data = await req.json()
    chat_id = data["message"]["chat"]["id"]
    text = data["message"].get("text", "")

    # Respuesta simple (sin await)
    httpx.post(f"{BASE_URL}/sendMessage", json={
        "chat_id": chat_id,
        "text": f"üì© Recib√≠ tu mensaje: {text}"
    })

    return {"ok": True}
